#!/usr/bin/env node

const gulp = require('gulp');
const gulpCoffee = require('gulp-coffee');
const gulpBabel = require('gulp-babel');
const gulpSass = require('gulp-sass');
const gulpWatch = require('gulp-watch');
const path = require('path');
const fs = require('fs');
const util = require('util');
const stream = require('stream');
const through2 = require('through2');
const argv = require('minimist')(process.argv.slice(2));
const chalk = require('chalk');
const packageJson = require('../package.json');

const errorColor = chalk.bold.red;
const infoColor = chalk.bold.green;
const dateColor = chalk.cyan;

const logDate = function() { // Add date with color
  var dt = new Date();
  return dateColor(dt.toLocaleTimeString()+':');
};

const folderAccessible = function(folder) { // Check folder access
  try { // IO errors
    if (!fs.statSync(folder).isDirectory()) { // Invalid folder
      // console.log('Folder:', folder, fs.accessSync(folder), fs.statSync(folder));
      return false;
    };
    return true;
  } catch (e) {
    // console.log('Error:', folder, e);
    return false;
  };
}

const folder = path.resolve(argv._[0] || '.');
if (!folderAccessible(folder)) { // Invalid folder
  console.error(errorColor('Folder is not accessible:'), folder);
  process.exit(1);
};

console.log(chalk.bold.magenta('=== Gulp build by convention ['+packageJson.version+'] ==='));

var app = argv.a;
if (app === undefined) { // Not set
  app = path.basename(folder);
};

console.log(infoColor('Start in:'), folder, infoColor('Application:'), app);

const fileEater = function(task_info, type) {
  return through2.obj(function (data, enc, cb) {
    // console.log('Eater:', data.path, type, data.contents? true: false);
    if (data.contents) { // Have something
      task_info.output.push({
        path: data.path,
        type: type
      });
    };
    this.push(data);
    cb();
  });
};

const jsConfig = {
  coffee: {
    task: function(task) {
      return task.pipe(gulpCoffee({
        bare: true
      }).on('error', function(err) { // Coffee compile error
        console.error(errorColor('Coffee Error:'), err.stack);
      }));
    }
  },
  jsx: {
    task: function(task) {
      return task.pipe(gulpBabel({
        presets: ['react']
      }));
    }
  },
  es6: {
    task: function(task) {
      return task.pipe(gulpBabel({
        presets: ['es2015']
      }));
    }
  },
};

const jsTasks = function(result) {
  var folders = fs.readdirSync(folder);
  var addTask = function(name, configs) {
    var task_info = {
      name: name,
      watch: path.join(folder, name, '**/*'),
      folder: name
    };
    gulp.task(name, function() {
      var task = gulp.src(path.join(folder, name, '**/*'));
      for (var id of configs) { // Make task
        task = jsConfig[id].task(task);
      };
      task = task
          .pipe(gulp.dest(path.join(folder, 'static', app, name)))
          .pipe(fileEater(task_info, 'js'));
      task_info.output = []; // Clear before run
      return task;
    });
    return task_info;
  };
  for (var name of folders) { // Check names
    // console.log('Folder:', name);
    var f = path.join(folder, name);
    if (!folderAccessible(f)) { // Skip
      continue;
    };
    var parts = name.split('-');
    var configs = [];
    for (var id of parts) {
      var conf = jsConfig[id];
      if (!conf) {
        continue;
      };
      configs.push(id);
    };
    if (!configs.length) { // Empty
      continue;
    };
    result.push(addTask(name, configs));
  };
};

const sassTasks = function(result) { // Sass stylesheets
  var name = 'scss';
  var f = path.join(folder, name);
  if (!folderAccessible(f)) { // Skip
    return;
  };
  var task_info = {
    name: name,
    watch: path.join(f, '**/*.scss'),
    folder: name
  };
  gulp.task(name, function() {
    var task = gulp.src(path.join(f, '**/[a-z]*.scss'))
        .pipe(gulpSass().on('error', gulpSass.logError))
        .pipe(gulp.dest(path.join(folder, 'static', app, name)))
        .pipe(fileEater(task_info, 'css'));
    task_info.output = []; // Clear before run
    return task;
  });
  result.push(task_info);
};

const headTasks = function(result) { // Look for head.json in folders
  var name = 'static';
  var f = path.join(folder, name);
  var search_path = '**/head*.json'
  var task_info = {
    name: name,
    watch: path.join(f, search_path),
    folder: name
  };
  gulp.task(name, function() {
    task_info.output = []; // Clear before run
    var headReader = through2.obj(function (data, enc, cb) {
      // console.log('Head', data.path, data.contents? true: false);
      if (data.contents) { // Have something
        try { // Parse JSON
          var json = JSON.parse(data.contents.toString());
          for (var item of json) { // Save to output
            var full_path = path.dirname(data.path);
            full_path = path.join(full_path, item);
            var type = path.extname(full_path) == '.css'? 'css': 'js';
            task_info.output.push({
              path: full_path,
              type: type
            });
            // console.log('Static resource:', full_path, type);
          };
        } catch (e) {
          console.error(errorColor('Invalid JSON:'), data.path, e);
        };
      };
      this.push(data);
      cb();
    });
    var task = gulp.src(path.join(f, search_path))
        .pipe(headReader);
    return task;
  });
  result.push(task_info);
};

var tasks = [];
const makeBundle = function() { // This will make bundle in folder
  var json = [];
  var base_path = path.join(folder, 'static');
  for (var task of tasks) { // Iterate over
    for (var item of task.output) { // Every file
      // console.log('Item:', item, path.relative(base_path, item.path));
      json.push({
        path: path.relative(base_path, item.path),
        type: item.type
      });
    };
  };
  try { // Save
    var file = fs.openSync(path.join(folder, 'head.json'), 'w');
    fs.writeSync(file, JSON.stringify(json));
    fs.closeSync(file);
    console.log(logDate(), infoColor('Updated head.json'));
  } catch (e) {
    console.error(errorColor('Error saving head.json'), e);
  };
};

const makeWatch = function() {
  var setWatchTask = function(task) {
    var watch_task_name = task.name+'-watch';
    gulp.task(watch_task_name, [task.name], makeBundle);
    gulpWatch(task.watch, function() { // 
      gulp.start([watch_task_name]);
    });
  };
  for (var task of tasks) { // Iterate over tasks
    if (task.watch) { // Have watch task
      setWatchTask(task);
    };
  };
  console.log(infoColor('Started in watch mode'));
};

headTasks(tasks);
sassTasks(tasks);
jsTasks(tasks);
var taskNames = [];
for (var task of tasks) { // Collect tasks
  taskNames.push(task.name);
};
console.log(logDate(), infoColor('Defined tasks:'), taskNames);

const distTask = gulp.task('dist', taskNames, makeBundle);

if (argv.w) { // Watch mode
  makeWatch();
};
gulp.start(['dist']);
