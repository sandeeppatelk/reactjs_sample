#!/usr/bin/env node
'use strict';

var gulp = require('gulp');
var gulpCoffee = require('gulp-coffee');
var gulpBabel = require('gulp-babel');
var gulpSass = require('gulp-sass');
var gulpWatch = require('gulp-watch');
var path = require('path');
var fs = require('fs');
var util = require('util');
var stream = require('stream');
var through2 = require('through2');
var argv = require('minimist')(process.argv.slice(2));
var chalk = require('chalk');
var packageJson = require('../package.json');

var errorColor = chalk.bold.red;
var infoColor = chalk.bold.green;
var dateColor = chalk.cyan;

var logDate = function logDate() {
  // Add date with color
  var dt = new Date();
  return dateColor(dt.toLocaleTimeString() + ':');
};

var folderAccessible = function folderAccessible(folder) {
  // Check folder access
  try {
    // IO errors
    if (!fs.statSync(folder).isDirectory()) {
      // Invalid folder
      // console.log('Folder:', folder, fs.accessSync(folder), fs.statSync(folder));
      return false;
    };
    return true;
  } catch (e) {
    // console.log('Error:', folder, e);
    return false;
  };
};

var folder = path.resolve(argv._[0] || '.');
if (!folderAccessible(folder)) {
  // Invalid folder
  console.error(errorColor('Folder is not accessible:'), folder);
  process.exit(1);
};

console.log(chalk.bold.magenta('=== Gulp build by convention [' + packageJson.version + '] ==='));

var app = argv.a;
if (app === undefined) {
  // Not set
  app = path.basename(folder);
};

console.log(infoColor('Start in:'), folder, infoColor('Application:'), app);

var fileEater = function fileEater(task_info, type) {
  return through2.obj(function (data, enc, cb) {
    // console.log('Eater:', data.path, type, data.contents? true: false);
    if (data.contents) {
      // Have something
      task_info.output.push({
        path: data.path,
        type: type
      });
    };
    this.push(data);
    cb();
  });
};

var jsConfig = {
  coffee: {
    task: function task(_task) {
      return _task.pipe(gulpCoffee({
        bare: true
      }).on('error', function (err) {
        // Coffee compile error
        console.error(errorColor('Coffee Error:'), err.stack);
      }));
    }
  },
  jsx: {
    task: function task(_task2) {
      return _task2.pipe(gulpBabel({
        presets: ['react']
      }));
    }
  },
  es6: {
    task: function task(_task3) {
      return _task3.pipe(gulpBabel({
        presets: ['es2015']
      }));
    }
  }
};

var jsTasks = function jsTasks(result) {
  var folders = fs.readdirSync(folder);
  var addTask = function addTask(name, configs) {
    var task_info = {
      name: name,
      watch: path.join(folder, name, '**/*'),
      folder: name
    };
    gulp.task(name, function () {
      var task = gulp.src(path.join(folder, name, '**/*'));
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = configs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var id = _step.value;
          // Make task
          task = jsConfig[id].task(task);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      ;
      task = task.pipe(gulp.dest(path.join(folder, 'static', app, name))).pipe(fileEater(task_info, 'js'));
      task_info.output = []; // Clear before run
      return task;
    });
    return task_info;
  };
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = folders[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var name = _step2.value;
      // Check names
      // console.log('Folder:', name);
      var f = path.join(folder, name);
      if (!folderAccessible(f)) {
        // Skip
        continue;
      };
      var parts = name.split('-');
      var configs = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = parts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var id = _step3.value;

          var conf = jsConfig[id];
          if (!conf) {
            continue;
          };
          configs.push(id);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      ;
      if (!configs.length) {
        // Empty
        continue;
      };
      result.push(addTask(name, configs));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  ;
};

var sassTasks = function sassTasks(result) {
  // Sass stylesheets
  var name = 'scss';
  var f = path.join(folder, name);
  if (!folderAccessible(f)) {
    // Skip
    return;
  };
  var task_info = {
    name: name,
    watch: path.join(f, '**/*.scss'),
    folder: name
  };
  gulp.task(name, function () {
    var task = gulp.src(path.join(f, '**/[a-z]*.scss')).pipe(gulpSass().on('error', gulpSass.logError)).pipe(gulp.dest(path.join(folder, 'static', app, name))).pipe(fileEater(task_info, 'css'));
    task_info.output = []; // Clear before run
    return task;
  });
  result.push(task_info);
};

var headTasks = function headTasks(result) {
  // Look for head.json in folders
  var name = 'static';
  var f = path.join(folder, name);
  var search_path = '**/head*.json';
  var task_info = {
    name: name,
    watch: path.join(f, search_path),
    folder: name
  };
  gulp.task(name, function () {
    task_info.output = []; // Clear before run
    var headReader = through2.obj(function (data, enc, cb) {
      // console.log('Head', data.path, data.contents? true: false);
      if (data.contents) {
        // Have something
        try {
          // Parse JSON
          var json = JSON.parse(data.contents.toString());
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = json[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var item = _step4.value;
              // Save to output
              var full_path = path.dirname(data.path);
              full_path = path.join(full_path, item);
              var type = path.extname(full_path) == '.css' ? 'css' : 'js';
              task_info.output.push({
                path: full_path,
                type: type
              });
              // console.log('Static resource:', full_path, type);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          ;
        } catch (e) {
          console.error(errorColor('Invalid JSON:'), data.path, e);
        };
      };
      this.push(data);
      cb();
    });
    var task = gulp.src(path.join(f, search_path)).pipe(headReader);
    return task;
  });
  result.push(task_info);
};

var tasks = [];
var makeBundle = function makeBundle() {
  // This will make bundle in folder
  var json = [];
  var base_path = path.join(folder, 'static');
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = tasks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var task = _step5.value;
      // Iterate over
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = task.output[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var item = _step6.value;
          // Every file
          // console.log('Item:', item, path.relative(base_path, item.path));
          json.push({
            path: path.relative(base_path, item.path),
            type: item.type
          });
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      ;
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  ;
  try {
    // Save
    var file = fs.openSync(path.join(folder, 'head.json'), 'w');
    fs.writeSync(file, JSON.stringify(json));
    fs.closeSync(file);
    console.log(logDate(), infoColor('Updated head.json'));
  } catch (e) {
    console.error(errorColor('Error saving head.json'), e);
  };
};

var makeWatch = function makeWatch() {
  var setWatchTask = function setWatchTask(task) {
    var watch_task_name = task.name + '-watch';
    gulp.task(watch_task_name, [task.name], makeBundle);
    gulpWatch(task.watch, function () {
      // 
      gulp.start([watch_task_name]);
    });
  };
  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = tasks[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var task = _step7.value;
      // Iterate over tasks
      if (task.watch) {
        // Have watch task
        setWatchTask(task);
      };
    }
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7.return) {
        _iterator7.return();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  ;
  console.log(infoColor('Started in watch mode'));
};

headTasks(tasks);
sassTasks(tasks);
jsTasks(tasks);
var taskNames = [];
var _iteratorNormalCompletion8 = true;
var _didIteratorError8 = false;
var _iteratorError8 = undefined;

try {
  for (var _iterator8 = tasks[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    var task = _step8.value;
    // Collect tasks
    taskNames.push(task.name);
  }
} catch (err) {
  _didIteratorError8 = true;
  _iteratorError8 = err;
} finally {
  try {
    if (!_iteratorNormalCompletion8 && _iterator8.return) {
      _iterator8.return();
    }
  } finally {
    if (_didIteratorError8) {
      throw _iteratorError8;
    }
  }
}

;
console.log(logDate(), infoColor('Defined tasks:'), taskNames);

var distTask = gulp.task('dist', taskNames, makeBundle);

if (argv.w) {
  // Watch mode
  makeWatch();
};
gulp.start(['dist']);